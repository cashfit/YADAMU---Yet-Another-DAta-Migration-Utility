---
layout: post
title:  "Introduction"
date:   2018-06-14 18:00:00-0700
categories: JSON Export Import Oracle
---
## An introduction to generating JSON with Oracle.

The JSON-Exchange project uses the JSON generation features of Oracle 12.2 and 18 to develop a simple JSON based replacement for the traditional Oracle EXP and IMP utilities. The basic concept is extremely simple, but as is often the case the devil is in the details. 

Oracle 12.2 introduced support for generating JSON directly from SQL. Of particular interest for this project are two operators, JSON_ARRAY and JSON_ARRAYAGG. JSON_ARRAY is used to generate a JSON array from each row returned by a SQL query, and JSON_ARRAYAGG is a aggregation operator that takes the set rows generated by a query and returns a single JSON array that contains one member for each row. 

The following queries  show how this works. You'll need to have the Oracle sample schemas, available [here](https://github.com/oracle/db-sample-schemas), installed to run this queries locally. Alternatively you can also run them on Oracle's [LiveSQL](https://livesql.oracle.com/apex/livesql/file/index.html) site, assuming you have an Oracle Technology Account. 

Let's start by looking at the content of the REGIONS table in the HR schema

```SQL
select REGION_ID, REGION_NAME
  from HR.REGIONS
/  
```

| REGION_ID | REGION_NAME            |
| --------- | ---------------------- |
| 1         | Europe                 |
| 2         | Americas               |
| 3         | Asia                   |
| 4         | Middle East and Africa |

To obtain a JSON array for each row we simply modify the statement, adding the JSON_ARRAY operator. The  NULL on NULL option ensures that each JSON array contains the number of elements, regardless of whether or not any of the columns in that row are NULL.

```SQL
select JSON_ARRAY(REGION_ID, REGION_NAME NULL ON NULL)
  from HR.REGIONS
/  
```

| JSON_ARRAY(REGION_ID,REGION_NAME) |
| --------------------------------- |
| [1,"Europe"]                      |
| [2,"Americas"]                    |
| [3,"Asia"]                        |
| [4,"Middle East and Africa"]      |

As can be see each row is now represented as JSON ARRAY. We can can turn the set of rows into a single JSON document by adding the JSON_ARRAYAGG operator.

```SQL
select JSON_ARRAYAGG(JSON_ARRAY(REGION_ID, REGION_NAME))
  from HR.REGIONS
/  
```

| JSON_ARRAYAGG(JSON_ARRAY(REGION_ID,REGION_NAME))             |
| ------------------------------------------------------------ |
| [[1,"Europe"],[2,"Americas"],[3,"Asia"],[4,"Middle East and Africa"]] |

As you can see we have now have a relatively simple SQL statement that provides a JSON representation of the entire table. 

In order to export the entire schema we can use something slightly more complex.

```SQL
select JSON_OBJECT(
         'data' value 
         JSON_OBJECT(
           'REGIONS' value
           (select JSON_ARRAYAGG(JSON_ARRAY(REGION_ID, ... NULL ON NULL) 
                                 RETURNING VARCHAR2(32767) from HR.REGIONS)
          ,'JOBS' value
           (select JSON_ARRAYAGG(JSON_ARRAY(JOB_ID,JOB_TITLE, ... NULL ON NULL)
                                 RETURNING VARCHAR2(32767)) from HR.JOBS)
          ...
          RETURNING VARCHAR2(32767)
         )
         RETURNING VARCHAR2(32767)    
       )
from dual
```

```JSON
{"data" : {
    "REGIONS" : [
        [1,"Europe"],
        [2,"Americas"],
        [3,"Asia"],
        [4,"Middle East and Africa"]
    ]
    ,"JOBS" : [
        ["AD_PRES","President",20080,40000],
        ["AD_VP","Administration Vice President",15000,30000],
        ...
        ["HR_REP","Human Resources Representative",4000,9000],
        ["PR_REP","Public Relations Representative",4500,10500]
    ]
    ....
}}
```

This statement, shown in abridged form, uses a separate select statement to generate a JSON_ARRAY for each table in the HR schema. The results of each statement are combined inside a "data" object that contains one key for each table in the schema. The key's name is the table name, and the keys value is a JSON array containing the data for that table. Using this technique we generate a single JSON document for the entire HR schema. 

The default return type used by the JSON operators is VARCHAR2(4000), this puts a fairly significant limitation on the size of the JSON documents that can be generated. While VARCHAR2(4000) maybe  reasonable when representing the contents of a single row as a JSON array, it is of pretty limited usefulness when representing the contents of a table as an array or arrays. 

Fortunately all of tthe JSON operators support a returning clause that can be used to override the operator's default return type. In Oracle 12.2, assuming that the database option MAX_STRING_SIZE = 'EXTENDED' has been enabled, the RETURNING clause can be used to specify that the generated JSON should be returned as a VARCHAR2(32767), making the operators far more useful. Database 18 supports CLOB as a return type, removing most practical limits on the size of the generated documents.  My understanding is that Oracle is currently in the process of preparing a patch for database 12.2 that will enable the use of CLOB a return type. 

Some of the arrays generated from the contents of the HR schema are larger than 4K, so the previous statement has been modified to specify that all the JSON operators should return VARCHAR2(32767). While this works for the "HR" schema, this technique will still fail in 12.2 when working with larger amounts of data, such as can be found in the "SH" schema. 

As can be seen from the above example, the SQL required to export an entire Oracle database schema as JSON is fairly straightforward. However for a schema with a large number of tables and columns the required statement quickly becomes quite large and hand coding such a statement becomes tedious and error prone. The next post will outline a PL/SQL package that uses Oracle's Data Dictionary to automate this process.