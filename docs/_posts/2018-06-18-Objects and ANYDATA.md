---
layout: post
title:  "Unsupported Data Types (Part 3)"
date:   2018-06-18 18:00:00-0700
categories: JSON Export Import Oracle
---



## Adding Support for Objects, Collections and ANYDATA.

The [previous]({% link _posts/2018-06-17-BFILE and BLOB.md%}) post showed how to use simple In-line PL/SQL procedures to support the BFILE and BLOB data types. This post will expand on that idea to add support for Object Types, Collection Types and the ANYDATA data type.

At first glance supporting Objects and Collections appeared to be simple, but as was mentioned earlier the Devil's in the details. The first approach considered was to leverage Oracle's ability to generate XML from an Object and to then covert that XML back into objects. Unfortunately as the following simple example shows that approach appears to be a non-starter  since it appears that NULL objects are transformed into empty objects

```SQL
SQL> set pages 0
SQL> set lines 132
SQL> with
  2  function XML_2_SDO_GEOMETRY(P_XMLTYPE XMLTYPE) return SDO_GEOMETRY
  3  as
  4    V_SDO_GEOMETRY SDO_GEOMETRY;
  5  begin
  6    P_XMLTYPE.TOOBJECT(V_SDO_GEOMETRY);
  7    return V_SDO_GEOMETRY;
  8  end;
  9  select WH_GEO_LOCATION, XML_2_SDO_GEOMETRY(XMLTYPE(WH_GEO_LOCATION))
 10    from OE.WAREHOUSES
 11   where WH_GEO_LOCATION is not NULL;
 12  /
```


```SQL
SDO_GEOMETRY(2001, 8307, SDO_POINT_TYPE(-103.00195, 36.500374, NULL), NULL, NULL)
SDO_GEOMETRY(2001, 8307, SDO_POINT_TYPE(-103.00195, 36.500374, NULL), SDO_ELEM_INFO_ARRAY(), SDO_ORDINATE_ARRAY())
```
The second approach considered was to try to handle Objects and Collections using Oracle's ANYDATA and ANYTYPE feature. This appeared quite promising at first, but the approach failed when attempting to deal with objects that contained non-scalar attributes. If ANYDATA provided a method to retrieve a non-scalar attribute as an instance of ANYDATA, the approach might have proved to be workable. Unfortunately the only was to fetch the value of non-scalar attribute from an ANYDATA is using code which knows ipso-facto what the object type of the attribute being fetched is. This makes it impossible to write generic ANYDATA based code that can traverse a nested hierarchy of objects without requiring baked-in knowledge of the structure of the objects. Attempts to work around this limitation  using execute immediate also proved fruitless, as the context of the piecewise operations used to traverse the attributes of an object appear to get lost when the ANYDATA object is passed as a bind variable. The final nail in the ANYDATA coffin was the discovery that ANYDATA does not support all of the scalar data types support by Oracle's object types. An example of this is the ORDSYS family of data types which declare attributes of data type INTEGER. These value of these attributes cannot be accessed using the methods provided by the ANYDATA object.

As can be seen above, when you retrieve an Oracle object in SQLPLUS it is serialized as a set of nested constructors. This representation makes quite a bit of sense, since the serialized representation is, in effect, the code required to recreate the object using SQL. Unfortunately while SQL*PLUS appears to contain the code required to serialize an object in this format, it does not appear that this functionality is exposed in SQL. One would have hoped that the TO_CHAR or TO_CLOB operators provided this functionality, or that Oracle could have provided a SERIALIZE operator, similar to XMLSERIALIZE, but it appears that this is not the case. 

The missing functionality was addressed by creating an OBJECT_SERIALIZATION package. This package takes an object, or set of objects, and generates a PL/SQL code that outputs a CLOB containing the serialized representation of an instance of that object. The code generated by the object will handle simple object types, complex types, e.g. types that contain non-scalar attributes, and collection types. It will also handle objects that are part of a type hierarchy. Creating this package was non-trivial but that is the subject of another post, maybe.

The package exposes two methods. The first, GENERATE_TABLE_TYPES is used when processing a schema on a table by table basis, while the second, GENERATE_SCHEMA_TYPES, is used when processing an entire schema in a single operation. Both methods return a PL/SQL procedure and a PL/SQL function called SERIALIZE_OBJECT. The function and procedure both expect the object to be serialized to be passed as an instance of the ANYDATA data type.

The function is simply  a wrapper for the procedure that creates the CLOB that contains the serialized representation of the object and invokes the procedure. When the SERIALIZE_OBJECT procedure completes the function returns the serialized representation of the object to the caller. This structure makes it possible to use a single CLOB to manage the object serialization process and invoke it directly from SQL.

The procedure consists of a PL/SQL block specific to each of object types that can be encountered while processing the target table or schema. Each block creates a serialized representation of a specific object type by printing it's attributes into a CLOB.  If an objects contains an attribute that is based on an object type or collection type, that attribute is serialized by converting it into an ANYDATA and making a recursive call to SERIALIZE_OBJECT. 

Since objects can contain attributes of type BFILE and BLOB the generated code makes use of the BFILE2CHAR and BLOB2HEXBINARY functions that were described in the previous post, and these functions are included in the PL/SQL code returned by GENERATE_TABLE_TYPES and GENERATE_SCHEMA_TYPES.. 

The other possibility for managing Object and Collection types is to generate a JSON representation of the object. Again, as of release 18, this functionality is not present in Oracle. Adding this functionality is one of a long list of enhancements under consideration future versions of the JSON_EXPORT package. However, the JSON serialization of an object would probably be much larger than the 'native' serialization, and so would not add value if we are simply interested in exporting data  from one Oracle database and importing into another.

Support for the ANYDATA data type was added by creating a function, SERIALIZE_ANYDATA, that serializes ANYDATA objects using logic similar to the logic used for serializing objects. However this function is limited in scope. Due to the issues outlined earlier in this post it does not handle ANYDATAs based on objects that have attributes whose data types that are not supported by ANYDATA, or ANYDATAs based on objects that contain attributes based on object or collection types.

Once the OBJECT_SERIALIZATION package was created it is relatively easy to incorporate the provided  functionality into the JSON_EXPORT package. The case statement in GENERATE_STATEMENT is modified to convert the contents of Object or Collection type columns into an ANYDATA instance and invoke the SERIALIZE_OBJECT function

```SQL
/*
**
** Support ANYDATA, OBJECT and COLLECTION types
**
*/
when DATA_TYPE = 'ANYDATA'  -- Can be owned by SYS or PUBLIC
   then 'case when "' ||  COLUMN_NAME || '" is NULL then NULL 
              else SERIALIZE_ANYDATA("' ||  COLUMN_NAME || '") 
         end'
when TYPECODE = 'COLLECTION'
  then 'case when "' || COLUMN_NAME || '" is NULL then NULL 
             else SERIALIZE_OBJECT(ANYDATA.convertCollection("' || COLUMN_NAME || '")) 
        end'
when TYPECODE = 'OBJECT'
  then 'case when "' || COLUMN_NAME || '" is NULL then NULL 
             else SERIALIZE_OBJECT(ANYDATA.convertObject("' || COLUMN_NAME || '")) 
        end'
```
 A left outer join with ALL_OBJECTS is required to allow the TYPECODE column to be used to differentiate Object and Collection types.				  

The GENERATE_WITH_CLAUSE method is modified to invoke the GENERATE_TABLE_TYPES or GENERATE_SCHEMA_TYPES functions as required and to add support for including the SERIALIZE_ANYDATA function into the WITH clause where necessary

```SQL
$IF JSON_FEATURE_DETECTION.CLOB_SUPPORTED $THEN
procedure GENERATE_WITH_CLAUSE(P_OWNER VARCHAR2, P_TABLE_NAME_LIST T_VC4000_TABLE, 
                               P_BFILE_COUNT NUMBER, P_BLOB_COUNT NUMBER, 
                               P_ANYDATA_COUNT NUMBER, P_SQL_STATEMENT IN OUT CLOB)
as
  V_OBJECT_SERIALIZER CLOB;
begin
  V_OBJECT_SERIALIZER := OBJECT_SERIALIZATION.SERIALIZE_TABLE_TYPES(P_OWNER,P_TABLE_NAME_LIST);
$ELSE
procedure GENERATE_WITH_CLAUSE(P_OWNER VARCHAR2, P_TABLE_NAME VARCHAR2, 
                               P_BFILE_COUNT NUMBER, P_BLOB_COUNT NUMBER, 
                               P_ANYDATA_COUNT NUMBER, P_SQL_STATEMENT IN OUT CLOB)
as
  V_OBJECT_SERIALIZER CLOB;
begin
  V_OBJECT_SERIALIZER :=  OBJECT_SERIALIZATION.SERIALIZE_TABLE_TYPES(P_OWNER,P_TABLE_NAME);	
$END
  if ((P_BFILE_COUNT + P_BLOB_COUNT + P_ANYDATA_COUNT=0) AND (V_OBJECT_SERIALIZER is NULL)) then
    return;
  end if;

  DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB('WITH' || C_NEWLINE));
  if (V_OBJECT_SERIALIZER is not null) then
    DBMS_LOB.APPEND(P_SQL_STATEMENT,V_OBJECT_SERIALIZER);
  else
    if ((P_BFILE_COUNT > 0) or (P_ANYDATA_COUNT > 0)) then
      DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(OBJECT_SERIALIZATION.CODE_BFILE2CHAR));
    end if;
    if ((P_BLOB_COUNT > 0) or (P_ANYDATA_COUNT > 0)) then
      DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(OBJECT_SERIALIZATION.CODE_BLOB2HEXBINARY));
    end if;
	if (P_ANYDATA_COUNT > 0) then
      DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(OBJECT_SERIALIZATION.CODE_SERIALIZE_ANYDATA));
	end if;
 end if;
end;
```

Once the necessary modifications have been made, EXPORT_SCHEMA successfully includes the content of the  WAREHOUSE and CUSTOMERS tables in the export file. However the Object tables CATEOGORIES_TAB and PURCHASEORDER are still excluded. The [next]({% link _posts/2018-06-19-Object and Wide Tables.md%}) post will examine what is required to add support for object tables to  the EXPORT_SCHEMA function.