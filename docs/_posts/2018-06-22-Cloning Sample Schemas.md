---
layout: post
title:  "Cloning Sample Schemas"
date:   2018-06-22 18:00:00-0700
categories: JSON Import Export Oracle
---

## Cloning Oracle's Sample Schemas

The previous post covered using DBMS_METADATA to include DDL operations the files created by EXPORT_SCHEMA and how t these DDL operations can be applied to the target schema before importing the data.This post will cover the testing performed on EXPORT_SCHEMA and IMPORT_JSON. The  success criteria established for the project is to successfully export and import the six Oracle supplied sample schemas. Testing will be performed by using the EXPORT_SCHEMA script to generate an export file for each of schemas and then using IMPORT_SCHEMA script to import each of the files into a newly created schema.  The process should complete without any FATAL errors being recorded in the log records generated by the import process. 

The results of running the tests with each of the sample schemas is shown in the following table:

| Schema | EXPORT_SCHEMA | IMPORT_JSON (DDL)            | IMPORT_JSON (DML)           |
| ------ | ------------- | ---------------------------- | --------------------------- |
| HR     | ✔️             | ✔️ (Duplicates)               | ✔️                           |
| SH     | ✔️             | ✔️ (Duplicates)               | ❌ (Materialized Views)      |
| OE     | ✔️             | ✔️ (Duplicates,References)    | ❌ (Objects, Mutating Table) |
| PM     | ✔️             | ✔️ (Duplicates,References)    | ❌ (Objects)                 |
| IX     | ✔️             | ✔️ (Duplicates,References,AQ) | ❌ (Objects)                 |
| BI     | ✔️             | ✔️                            | ✔️ (No data to import)       |

At this point the EXPORT_SCHEMA and IMPORT_JSCHEMA scripts can be used to clone the HR and BI schemas. However further modifications are required to handle the issues that arise when attempting to clone the SH, OE, PM and IX schemas

Cloning the SH Schema fails when it attempts an "INSERT as SELECT" operation on a materialized view. The cause of the problem is EXPORT_SCHEMA included the content of the materialized view in the export file. Materialized views are included because they appear in the view ALL_ALL_TABLES, which is referenced in the SQL used by GENERATE_STATEMENETS to determine which objects to export. The solution to this problem is to simply exclude materialized views from the export file.

Materialized views are excluded from the export file by adding a left outer join with ALL_MVIEWS to  the SQL used by GENERATE_STATEMENTS and applying a filter that removes rows where MVIEW_NAME is not null. The code for this is shown below

```SQL
    from ALL_ALL_TABLES aat
         inner join ALL_TAB_COLS atc
                 on atc.OWNER = aat.OWNER
                and atc.TABLE_NAME = aat.TABLE_NAME
    left outer join ALL_TYPES at
                 on at.TYPE_NAME = atc.DATA_TYPE
                and at.OWNER = atc.DATA_TYPE_OWNER
    left outer join ALL_MVIEWS amv
		         on amv.OWNER = aat.OWNER
		        and amv.MVIEW_NAME = aat.TABLE_NAME
   where aat.STATUS = 'VALID'
     and aat.DROPPED = 'NO'
     and aat.TEMPORARY = 'N'
     and aat.EXTERNAL = 'NO'
     and aat.NESTED = 'NO'
     and aat.SECONDARY = 'N'
     and (aat.IOT_TYPE is NULL or aat.IOT_TYPE = 'IOT')
     and (
           ((TABLE_TYPE is NULL) and (HIDDEN_COLUMN = 'NO'))
         or 
           (
               (TABLE_TYPE is not NULL) 
               and 
               (COLUMN_NAME in ('SYS_NC_ROWINFO$','SYS_NC_OID$','ACLOID','OWNERID'))
           )
         )        
	 and amv.MVIEW_NAME is NULL
     and aat.OWNER = P_SCHEMA
   group by aat.OWNER, aat.TABLE_NAME;
```

Since the data for the materialized views in excluded from the export file the materialized views must be 

Cloning the OE schema fails when importing the ORDER_ITEMS table due to a  "mutating table" error. The error occurs because there is a trigger on the table that prevents bulk operations, such as INSERT as SELECT from executing. This issue is solved by modifying IMPORT_JSON to catch the mutating table exception, and re-attempt the import operation using a PL/SQL cursor that inserts the rows one at a time.

Cloning OE, PM and IX schemas also fails due to issues related to Oracle object types. EXPORT_SCHEMA required custom PL/SQL code to serialize objects, and custom PL/SQL is required to parse the serialized representation. Oracle does not expose a generic parser for Oracle objects, fortunately there is a relatively simple solution, all that is required to parse the object is to wrap the serialized representation of the object in a "select ... from dual" operation and execute the code using EXECUTE IMMEDIATE. This causes Oracle to parse the object and return an instance of the object type. A separate function is required for each type of object, as the function definition must specify the type of object returned. A sample parse function is shown below

```SQL
function "#SDO_GEOMETRY"(P_SERIALIZATION CLOB) return "MDSYS"."SDO_GEOMETRY"
as
  V_OBJECT "MDSYS"."SDO_GEOMETRY";
begin
  if (P_SERIALIZATION is NULL) then return NULL; end if;
  EXECUTE IMMEDIATE 'SELECT ' || P_SERIALIZATION || ' FROM DUAL' into V_OBJECT;
  return V_OBJECT;
end;
```

The required set of functions is  added to a WITH clause that is prepended to the SQL used to ingest the JSON.

After making the changes outlined above, all of the EXPORT_SCHMEA and IMPORT_JSON operations succeed. 

| Schema | EXPORT_SCHEMA | IMPORT_JSON (DDL)            | IMPORT_JSON (DML) |
| ------ | ------------- | ---------------------------- | ----------------- |
| HR     | ✔️             | ✔️ (Duplicates)               | ✔️                 |
| SH     | ✔️             | ✔️ (Duplicates)               | ✔️                 |
| OE     | ✔️             | ✔️ (Duplicates,References)    | ✔️                 |
| PM     | ✔️             | ✔️ (Duplicates,References)    | ✔️                 |
| IX     | ✔️             | ✔️ (Duplicates,References,AQ) | ✔️                 |
| BI     | ✔️             | ✔️                            | ✔️                 |

The scripts VALIDATE_STRUCTURE.sql and VALIDATE_CONTENT.sql, located in the test folder, test  the fidelity of the cloned schema. VALIDATE_STRUCTURE use the ALL_OBJECTS view  to compare the structure of the source and target schema  and generates a report showing any consistencies detected. 

VALIDATE_CONTENT uses the SQL minus operator to compare the content of each table in the source and target schema, and generates a summary report summarizing any mismatched data.  The SQL minus operator does not extended data types such as LOBs, XMLType and Oracle object types. VALIDATE_CONTENT compares values in columns of these types by using the hash function on package DBMS_CRYTPO to compute a SHA-256 Hash of the (serialized) content of the column. This can only be done if the user running VALIDATE_CONTENT has been granted execute permission on DBMS_CRYPTO.

The results of running VALIDATE_STRUCTURE and VALIDATE_CONTENT are shown below. End to End testing has only been completed on Oracle 12cR2 without the patch to enabl CLOB as a return type for JSON_OBJECT, JSON_ARRAY and JSON_ARRAYAGG.

| Schema | STRUCTURE       | CONTENT (-CLOB)               | CONTENT (+CLOB)          |
| ------ | --------------- | ----------------------------- | ------------------------ |
| HR     | ✔️ (34 Objects)  | ✔️                             | Cannot Test with LiveSQL |
| SH     | ✔️ (58 Objects)  | ✔️                             | Cannot Test with LiveSQL |
| OE     | ✔️ (107 Objects) | ✔️ (177 Diffs due to Triggers) | Cannot Test with LiveSQL |
| PM     | ✔️ (10 Objects)  | ✔️ (11 Diffs due to LOBs)      | Cannot Test with LiveSQL |
| IX     | ✔️ (46 Objects)  | ✔️                             | Cannot Test with LiveSQL |
| BI     | ✔️ (8 Objects)   | No Data                       | Cannot Test with LiveSQL |

