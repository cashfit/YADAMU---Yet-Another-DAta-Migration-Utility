--
create or replace type T_VC4000_TABLE is TABLE of VARCHAR2(4000)
/
--
/*
** Avoid JSON_ARRAYAGG when CLOB is not a supported return type
** Generate one SQL per table rathen one SQL per export
*/  
create or replace package JSON_EXPORT
authid CURRENT_USER
as
  ROW_LIMIT NUMBER := -1;
  procedure SET_ROW_LIMIT(P_ROW_LIMIT NUMBER);
--
$IF JSON_FEATURE_DETECTION.CLOB_SUPPORTED $THEN
--
  SQL_STATEMENT CLOB;
  function DUMP_SQL_STATEMENT return CLOB;
--
$ELSE
--
  type T_EXPORT_METADATA_RECORD is record(
    OWNER         VARCHAR2(128)
   ,TABLE_NAME    VARCHAR2(128)
   ,SQL_STATEMENT CLOB
  );
  
  type T_EXPORT_METADATA_TABLE is table of T_EXPORT_METADATA_RECORD;
  EXPORT_METADATA_CACHE T_EXPORT_METADATA_TABLE;
--  
  function EXPORT_METADATA return T_EXPORT_METADATA_TABLE pipelined;
$END  
--
  function EXPORT_SCHEMA(P_SOURCE_SCHEMA VARCHAR2 DEFAULT SYS_CONTEXT('USERENV','CURRENT_SCHEMA')) return CLOB;
end;
/
--
show errors 
--
create or replace package body JSON_EXPORT
as
--
  C_NEWLINE         CONSTANT CHAR(1) := CHR(10);
  C_SINGLE_QUOTE    CONSTANT CHAR(1) := CHR(39);
--
  $IF JSON_FEATURE_DETECTION.CLOB_SUPPORTED $THEN
  C_RETURN_TYPE CONSTANT VARCHAR2(32) := 'CLOB';
  $ELSIF JSON_FEATURE_DETECTION.EXTENDED_STRING_SUPPORTED $THEN
  C_RETURN_TYPE CONSTANT VARCHAR2(32):= 'VARCHAR2(32767)';
  $ELSE
  C_RETURN_TYPE CONSTANT VARCHAR2(32):= 'VARCHAR2(4000)';
  $END  
--
$IF JSON_FEATURE_DETECTION.CLOB_SUPPORTED $THEN
--
function DUMP_SQL_STATEMENT
return CLOB
as
begin
  return SQL_STATEMENT;
end;
--
$ELSE
--
function EXPORT_METADATA
return T_EXPORT_METADATA_TABLE
pipelined
as
  cursor getRecords
  is
  select *
    from TABLE(EXPORT_METADATA_CACHE);
begin
  for r in getRecords loop
    pipe row (r);
  end loop;
end;
--
$END
--
procedure SET_ROW_LIMIT(P_ROW_LIMIT NUMBER)
as
begin
  ROW_LIMIT := P_ROW_LIMIT;
end;
--
function TABLE_TO_LIST(P_TABLE T_VC4000_TABLE,P_DELIMITER VARCHAR2 DEFAULT ',') 
return CLOB
as
  V_LIST CLOB;
begin
  DBMS_LOB.CREATETEMPORARY(V_LIST,TRUE,DBMS_LOB.CALL);
  for i in P_TABLE.first .. P_TABLE.last loop
    if (i > 1) then 
  	  DBMS_LOB.WRITEAPPEND(V_LIST,length(P_DELIMITER),P_DELIMITER); 
	end if;
	DBMS_LOB.WRITEAPPEND(V_LIST,length(P_TABLE(i)),P_TABLE(i));
  end loop;
  return V_LIST;
end;
--
procedure GENERATE_STATEMENT(P_SOURCE_SCHEMA VARCHAR2)
/*
** Generate SQL Statement to create a JSON document from the contents of the supplied schema.
*/
as
  V_SQL_FRAGMENT  VARCHAR2(32767);
  
  cursor getTableMetadata
  is
  select aat.owner
        ,aat.table_name
		,cast(collect('"' || COLUMN_NAME || '"' order by COLUMN_ID) as T_VC4000_TABLE) COLUMN_LIST
    from ALL_ALL_TABLES aat
	     inner join ALL_TAB_COLUMNS atc
		         on atc.OWNER = aat.OWNER
		        and atc.TABLE_NAME = aat.TABLE_NAME
   where aat.STATUS = 'VALID'
     and aat.DROPPED = 'NO'
	 and aat.TEMPORARY = 'N'
     and aat.EXTERNAL = 'NO'
	 and aat.NESTED = 'NO'
	 and aat.SECONDARY = 'N'
	 and (aat.IOT_TYPE is NULL or aat.IOT_TYPE = 'IOT')
	 and aat.TABLE_TYPE is NULL
	 and aat.OWNER = P_SOURCE_SCHEMA
   group by aat.OWNER, aat.TABLE_NAME;
   
  V_FIRST_ROW BOOLEAN := TRUE;
begin
--
$IF JSON_FEATURE_DETECTION.CLOB_SUPPORTED $THEN
--
  DBMS_LOB.CREATETEMPORARY(SQL_STATEMENT,TRUE,DBMS_LOB.CALL);
  V_SQL_FRAGMENT := 'select JSON_OBJECT(''data'' value JSON_OBJECT (' || C_NEWLINE;
  DBMS_LOB.WRITEAPPEND(SQL_STATEMENT,length(V_SQL_FRAGMENT),V_SQL_FRAGMENT);

  for t in getTableMetadata loop  
	V_SQL_FRAGMENT := C_SINGLE_QUOTE || t.TABLE_NAME || C_SINGLE_QUOTE || ' value ( select JSON_ARRAYAGG(JSON_ARRAY(';
    if (not V_FIRST_ROW) then
      V_SQL_FRAGMENT := ',' || V_SQL_FRAGMENT;
	end if;
	V_FIRST_ROW := FALSE;
	DBMS_LOB.WRITEAPPEND(SQL_STATEMENT,length(V_SQL_FRAGMENT),V_SQL_FRAGMENT);
	DBMS_LOB.APPEND(SQL_STATEMENT,TABLE_TO_LIST(t.COLUMN_LIST));
    V_SQL_FRAGMENT := ' NULL on NULL returning ' || C_RETURN_TYPE || ') returning ' || C_RETURN_TYPE || ') from "' || t.OWNER || '"."' || t.TABLE_NAME || '"';
	if (ROW_LIMIT > -1) then
	  V_SQL_FRAGMENT := V_SQL_FRAGMENT || 'where ROWNUM < ' || ROW_LIMIT;
	end if;
	V_SQL_FRAGMENT :=  V_SQL_FRAGMENT || ')' || C_NEWLINE;
	DBMS_LOB.WRITEAPPEND(SQL_STATEMENT,length(V_SQL_FRAGMENT),V_SQL_FRAGMENT);
  end loop;

  V_SQL_FRAGMENT := '             returning ' || C_RETURN_TYPE || C_NEWLINE
                 || '           )' || C_NEWLINE
                 || '         returning ' || C_RETURN_TYPE || C_NEWLINE
                 || '       )' || C_NEWLINE
                 || '  from DUAL';
  DBMS_LOB.WRITEAPPEND(SQL_STATEMENT,length(V_SQL_FRAGMENT),V_SQL_FRAGMENT);
-- 
$ELSE
--
  declare
    V_SQL_STATEMENT CLOB;
  begin
    EXPORT_METADATA_CACHE := T_EXPORT_METADATA_TABLE();
    for t in getTableMetadata loop  
      EXPORT_METADATA_CACHE.extend();
	  EXPORT_METADATA_CACHE(EXPORT_METADATA_CACHE.count).OWNER := t.OWNER;
	  EXPORT_METADATA_CACHE(EXPORT_METADATA_CACHE.count).TABLE_NAME := t.TABLE_NAME;

      DBMS_LOB.CREATETEMPORARY(V_SQL_STATEMENT,TRUE,DBMS_LOB.CALL);
      V_SQL_FRAGMENT := 'select JSON_ARRAY(';
      DBMS_LOB.WRITEAPPEND(V_SQL_STATEMENT,length(V_SQL_FRAGMENT),V_SQL_FRAGMENT);
      DBMS_LOB.APPEND(V_SQL_STATEMENT,TABLE_TO_LIST(t.COLUMN_LIST));
      V_SQL_FRAGMENT := ' NULL on NULL returning '|| C_RETURN_TYPE || ') from "' || t.OWNER || '"."' || t.TABLE_NAME || '"';
  	  if (ROW_LIMIT > -1) then
	    V_SQL_FRAGMENT := V_SQL_FRAGMENT || 'where ROWNUM < ' || ROW_LIMIT;
	  end if;
      DBMS_LOB.WRITEAPPEND(V_SQL_STATEMENT,length(V_SQL_FRAGMENT),V_SQL_FRAGMENT);
      EXPORT_METADATA_CACHE(EXPORT_METADATA_CACHE.count).SQL_STATEMENT := V_SQL_STATEMENT;	
    end loop;
  end;	
$END
--
end;
--
$IF JSON_FEATURE_DETECTION.CLOB_SUPPORTED $THEN
--
function EXPORT_SCHEMA(P_SOURCE_SCHEMA VARCHAR2 DEFAULT SYS_CONTEXT('USERENV','CURRENT_SCHEMA')))
return CLOB
as
  V_JSON_DOCUMENT CLOB;
  V_CURSOR      SYS_REFCURSOR;
begin
  GENERATE_STATEMENT(P_SOURCE_SCHEMA);
  open V_CURSOR for SQL_STATEMENT;
  fetch V_CURSOR into V_JSON_DOCUMENT;
  close V_CURSOR;
  return V_JSON_DOCUMENT;
end;
--  
$ELSE
--
function EXPORT_SCHEMA(P_SOURCE_SCHEMA VARCHAR2 DEFAULT SYS_CONTEXT('USERENV','CURRENT_SCHEMA'))
return CLOB
as
  V_JSON_DOCUMENT CLOB;
  V_CURSOR        SYS_REFCURSOR;

  V_JSON_FRAGMENT VARCHAR2(4000);
  
  V_FIRST_TABLE   BOOLEAN := TRUE;
  V_FIRST_ITEM    BOOLEAN := TRUE;
--  
  $IF JSON_FEATURE_DETECTION.EXTENDED_STRING_SUPPORTED $THEN
  V_JSON_ARRAY VARCHAR2(32767);
  $ELSE
  V_JSON_ARRAY VARCHAR2(4000);
  $END  
--
begin
  GENERATE_STATEMENT(P_SOURCE_SCHEMA);
  DBMS_LOB.CREATETEMPORARY(V_JSON_DOCUMENT,TRUE,DBMS_LOB.CALL);
  V_JSON_FRAGMENT := '{"data":{';
  DBMS_LOB.WRITEAPPEND(V_JSON_DOCUMENT,length(V_JSON_FRAGMENT),V_JSON_FRAGMENT);
  for i in 1 .. EXPORT_METADATA_CACHE.count loop
    V_JSON_FRAGMENT := '"' || EXPORT_METADATA_CACHE(i).table_name || '":[';
	if (not V_FIRST_TABLE) then 
  	  V_JSON_FRAGMENT := ',' || V_JSON_FRAGMENT;
	end if;
	V_FIRST_TABLE := false;
	DBMS_LOB.WRITEAPPEND(V_JSON_DOCUMENT,length(V_JSON_FRAGMENT),V_JSON_FRAGMENT);
    V_FIRST_ITEM := TRUE;
    open V_CURSOR for EXPORT_METADATA_CACHE(i).SQL_STATEMENT;
	loop
	  fetch V_CURSOR into V_JSON_ARRAY;
	  exit when V_CURSOR%notfound;	  
	  if (not V_FIRST_ITEM) then
    	DBMS_LOB.WRITEAPPEND(V_JSON_DOCUMENT,1,',');
	  end if;
 	  V_FIRST_ITEM := FALSE;
      DBMS_LOB.WRITEAPPEND(V_JSON_DOCUMENT,length(V_JSON_ARRAY),V_JSON_ARRAY);
	end loop;
	close V_CURSOR;
    DBMS_LOB.WRITEAPPEND(V_JSON_DOCUMENT,1,']');
  end loop;
  DBMS_LOB.WRITEAPPEND(V_JSON_DOCUMENT,1,'}');
  DBMS_LOB.WRITEAPPEND(V_JSON_DOCUMENT,1,'}');
  return V_JSON_DOCUMENT;
end;
--
$END
--
end;
/
show errors
--
spool off
--