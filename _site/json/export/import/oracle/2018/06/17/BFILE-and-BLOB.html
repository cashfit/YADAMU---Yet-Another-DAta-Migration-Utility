<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Unsupported Data Types (Part 2) | JSON Exchange</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Unsupported Data Types (Part 2)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Using In-line PL/SQL to support BFILE and BLOB The previous post showed how to use SQL conversions to extend the set of data types that can be used with JSON_ARRAY. This post will build on that concept showing how in-line PL/SQL can be used in places where pure SQL is not sufficient. JSON_ARRAY does not support the BFILE data type in any current release of the Oracle Database. A BFILE is basically a pointer to a file stored outside the database. The pointer consists of two components, a SQL Directory name and a path to the file, relative to the folder associated with the directory. There are 2 approaches to supporting the BFILE datatype. The first is to inline the content of the file directly into the export, the second is to serialize the BFILE as a directory name and a relative path. In the current implementation of EXPORT_SCHEMA the second option is used. It is not possible to extract this information directly a from BFILE column using SQL, so PL/SQL needs to be used. The PL/SQL is extremely simple, given a BFILE column the method DBMS_LOB.FILEGETNAME will return the directory name and filename. However, since the FILEGETNAME method uses OUT parameters to return the required information it cannot be called directly from SQL, so a PL/SQL wrapper is required to allow FILEGETNAME to be invoked as part of the JSON_ARRAY operation. The wrapper function is show below function BFILE2CHAR(P_BFILE BFILE) return VARCHAR2 as V_SINGLE_QUOTE CONSTANT CHAR(1) := CHR(39); V_DIRECTORY_ALIAS VARCHAR2(128 CHAR); V_PATH2FILE VARCHAR2(2000 CHAR); begin DBMS_LOB.FILEGETNAME(P_BFILE,V_DIRECTORY_ALIAS,V_PATH2FILE); return &#39;BFILENAME(&#39; || V_SINGLE_QUOTE || V_DIRECTORY_ALIAS || V_SINGLE_QUOTE || &#39;,&#39; || V_SINGLE_QUOTE || V_PATH2FILE || V_SINGLE_QUOTE || &#39;)&#39;; end; It returns the directory and file names as the SQL function that was used when the BFILE was created. A similar approach is taken in Oracle 12 when dealing with BLOB datatypes. Oracle 18 correctly outputs BLOB content as a HEXBINARY string. This behavior is mimicked in Oracle 12 by supplying a PL/SQL wrapper that returns a CLOB containing the HEXBINARY representation of the BLOB. The maximum size that can be handled using this approach is limited based on the return type specified for the JSON_ARRAY operation. Consequently, an error will be returned if the HEXBINARY representation of the input document is larger than the maximum size supported by the JSON_ARRAY operator. The size check assumes that the BLOB column is the only input to JSON_ARRAY, and it’s primary use is to avoid the overhead of serializing large documents in cases where the generated output cannot be processed further. The following changes were made to the case statement in GENERATE_SCHEMA. For handling BLOBS in release 12 /* ** 18.1 compatible handling of BLOB */ when DATA_TYPE = &#39;BLOB&#39; then &#39;BLOB2HEXBINARY(&quot;&#39; || COLUMN_NAME || &#39;&quot;)&#39; and for handling BFILES in all releases /* ** Fix for BFILENAME */ when DATA_TYPE = &#39;BFILE&#39; then &#39;BFILE2CHAR(&quot;&#39; || COLUMN_NAME || &#39;&quot;)&#39; In order to enable the use of these functions from EXPORT_SCHEMA a WITH clause containing the PL/SQL code is added the SQL statement(s) created by GENERATE_SCHEMA. To ensure that the WITH block is only added when necessary, the query in GENERATE_SCHEMA is modified to count the number of BLOB and BFILE columns for each table as shown below select aat.owner ,aat.table_name ,SUM(CASE WHEN DATA_TYPE = &#39;BLOB&#39; THEN 1 ELSE 0 END) BLOB_COUNT ,SUM(CASE WHEN DATA_TYPE = &#39;BFILE&#39; THEN 1 ELSE 0 END) BFILE_COUNT ,cast(collect... A new method, GENERATE_WITH_CLAUSE is added to generate the WITH clause procedure GENERATE_WITH_CLAUSE(P_BFILE_COUNT NUMBER, P_BLOB_COUNT NUMBER, P_SQL_STATEMENT IN OUT CLOB) as begin if ((P_BFILE_COUNT = 0) and (P_BLOB_COUNT = 0)) then return; end if; DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(&#39;WITH&#39; || C_NEWLINE)); if (P_BFILE_COUNT &gt; 0) then DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(CODE_BFILE2CHAR)); end if; if (P_BLOB_COUNT &gt; 0) then DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(CODE_BLOB2HEXBINARY)); end if; end; This method is invoked in GENERATE schema prior to printing the ‘select’ into the LOB that contains the generated SQL statement. The next post will discuss how a similar technique can be used to support Oracle OBJECT types and the ANYDATA type." />
<meta property="og:description" content="Using In-line PL/SQL to support BFILE and BLOB The previous post showed how to use SQL conversions to extend the set of data types that can be used with JSON_ARRAY. This post will build on that concept showing how in-line PL/SQL can be used in places where pure SQL is not sufficient. JSON_ARRAY does not support the BFILE data type in any current release of the Oracle Database. A BFILE is basically a pointer to a file stored outside the database. The pointer consists of two components, a SQL Directory name and a path to the file, relative to the folder associated with the directory. There are 2 approaches to supporting the BFILE datatype. The first is to inline the content of the file directly into the export, the second is to serialize the BFILE as a directory name and a relative path. In the current implementation of EXPORT_SCHEMA the second option is used. It is not possible to extract this information directly a from BFILE column using SQL, so PL/SQL needs to be used. The PL/SQL is extremely simple, given a BFILE column the method DBMS_LOB.FILEGETNAME will return the directory name and filename. However, since the FILEGETNAME method uses OUT parameters to return the required information it cannot be called directly from SQL, so a PL/SQL wrapper is required to allow FILEGETNAME to be invoked as part of the JSON_ARRAY operation. The wrapper function is show below function BFILE2CHAR(P_BFILE BFILE) return VARCHAR2 as V_SINGLE_QUOTE CONSTANT CHAR(1) := CHR(39); V_DIRECTORY_ALIAS VARCHAR2(128 CHAR); V_PATH2FILE VARCHAR2(2000 CHAR); begin DBMS_LOB.FILEGETNAME(P_BFILE,V_DIRECTORY_ALIAS,V_PATH2FILE); return &#39;BFILENAME(&#39; || V_SINGLE_QUOTE || V_DIRECTORY_ALIAS || V_SINGLE_QUOTE || &#39;,&#39; || V_SINGLE_QUOTE || V_PATH2FILE || V_SINGLE_QUOTE || &#39;)&#39;; end; It returns the directory and file names as the SQL function that was used when the BFILE was created. A similar approach is taken in Oracle 12 when dealing with BLOB datatypes. Oracle 18 correctly outputs BLOB content as a HEXBINARY string. This behavior is mimicked in Oracle 12 by supplying a PL/SQL wrapper that returns a CLOB containing the HEXBINARY representation of the BLOB. The maximum size that can be handled using this approach is limited based on the return type specified for the JSON_ARRAY operation. Consequently, an error will be returned if the HEXBINARY representation of the input document is larger than the maximum size supported by the JSON_ARRAY operator. The size check assumes that the BLOB column is the only input to JSON_ARRAY, and it’s primary use is to avoid the overhead of serializing large documents in cases where the generated output cannot be processed further. The following changes were made to the case statement in GENERATE_SCHEMA. For handling BLOBS in release 12 /* ** 18.1 compatible handling of BLOB */ when DATA_TYPE = &#39;BLOB&#39; then &#39;BLOB2HEXBINARY(&quot;&#39; || COLUMN_NAME || &#39;&quot;)&#39; and for handling BFILES in all releases /* ** Fix for BFILENAME */ when DATA_TYPE = &#39;BFILE&#39; then &#39;BFILE2CHAR(&quot;&#39; || COLUMN_NAME || &#39;&quot;)&#39; In order to enable the use of these functions from EXPORT_SCHEMA a WITH clause containing the PL/SQL code is added the SQL statement(s) created by GENERATE_SCHEMA. To ensure that the WITH block is only added when necessary, the query in GENERATE_SCHEMA is modified to count the number of BLOB and BFILE columns for each table as shown below select aat.owner ,aat.table_name ,SUM(CASE WHEN DATA_TYPE = &#39;BLOB&#39; THEN 1 ELSE 0 END) BLOB_COUNT ,SUM(CASE WHEN DATA_TYPE = &#39;BFILE&#39; THEN 1 ELSE 0 END) BFILE_COUNT ,cast(collect... A new method, GENERATE_WITH_CLAUSE is added to generate the WITH clause procedure GENERATE_WITH_CLAUSE(P_BFILE_COUNT NUMBER, P_BLOB_COUNT NUMBER, P_SQL_STATEMENT IN OUT CLOB) as begin if ((P_BFILE_COUNT = 0) and (P_BLOB_COUNT = 0)) then return; end if; DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(&#39;WITH&#39; || C_NEWLINE)); if (P_BFILE_COUNT &gt; 0) then DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(CODE_BFILE2CHAR)); end if; if (P_BLOB_COUNT &gt; 0) then DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(CODE_BLOB2HEXBINARY)); end if; end; This method is invoked in GENERATE schema prior to printing the ‘select’ into the LOB that contains the generated SQL statement. The next post will discuss how a similar technique can be used to support Oracle OBJECT types and the ANYDATA type." />
<link rel="canonical" href="http://localhost:4000/json/export/import/oracle/2018/06/17/BFILE-and-BLOB.html" />
<meta property="og:url" content="http://localhost:4000/json/export/import/oracle/2018/06/17/BFILE-and-BLOB.html" />
<meta property="og:site_name" content="JSON Exchange" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-17T18:00:00-07:00" />
<script type="application/ld+json">
{"description":"Using In-line PL/SQL to support BFILE and BLOB The previous post showed how to use SQL conversions to extend the set of data types that can be used with JSON_ARRAY. This post will build on that concept showing how in-line PL/SQL can be used in places where pure SQL is not sufficient. JSON_ARRAY does not support the BFILE data type in any current release of the Oracle Database. A BFILE is basically a pointer to a file stored outside the database. The pointer consists of two components, a SQL Directory name and a path to the file, relative to the folder associated with the directory. There are 2 approaches to supporting the BFILE datatype. The first is to inline the content of the file directly into the export, the second is to serialize the BFILE as a directory name and a relative path. In the current implementation of EXPORT_SCHEMA the second option is used. It is not possible to extract this information directly a from BFILE column using SQL, so PL/SQL needs to be used. The PL/SQL is extremely simple, given a BFILE column the method DBMS_LOB.FILEGETNAME will return the directory name and filename. However, since the FILEGETNAME method uses OUT parameters to return the required information it cannot be called directly from SQL, so a PL/SQL wrapper is required to allow FILEGETNAME to be invoked as part of the JSON_ARRAY operation. The wrapper function is show below function BFILE2CHAR(P_BFILE BFILE) return VARCHAR2 as V_SINGLE_QUOTE CONSTANT CHAR(1) := CHR(39); V_DIRECTORY_ALIAS VARCHAR2(128 CHAR); V_PATH2FILE VARCHAR2(2000 CHAR); begin DBMS_LOB.FILEGETNAME(P_BFILE,V_DIRECTORY_ALIAS,V_PATH2FILE); return &#39;BFILENAME(&#39; || V_SINGLE_QUOTE || V_DIRECTORY_ALIAS || V_SINGLE_QUOTE || &#39;,&#39; || V_SINGLE_QUOTE || V_PATH2FILE || V_SINGLE_QUOTE || &#39;)&#39;; end; It returns the directory and file names as the SQL function that was used when the BFILE was created. A similar approach is taken in Oracle 12 when dealing with BLOB datatypes. Oracle 18 correctly outputs BLOB content as a HEXBINARY string. This behavior is mimicked in Oracle 12 by supplying a PL/SQL wrapper that returns a CLOB containing the HEXBINARY representation of the BLOB. The maximum size that can be handled using this approach is limited based on the return type specified for the JSON_ARRAY operation. Consequently, an error will be returned if the HEXBINARY representation of the input document is larger than the maximum size supported by the JSON_ARRAY operator. The size check assumes that the BLOB column is the only input to JSON_ARRAY, and it’s primary use is to avoid the overhead of serializing large documents in cases where the generated output cannot be processed further. The following changes were made to the case statement in GENERATE_SCHEMA. For handling BLOBS in release 12 /* ** 18.1 compatible handling of BLOB */ when DATA_TYPE = &#39;BLOB&#39; then &#39;BLOB2HEXBINARY(&quot;&#39; || COLUMN_NAME || &#39;&quot;)&#39; and for handling BFILES in all releases /* ** Fix for BFILENAME */ when DATA_TYPE = &#39;BFILE&#39; then &#39;BFILE2CHAR(&quot;&#39; || COLUMN_NAME || &#39;&quot;)&#39; In order to enable the use of these functions from EXPORT_SCHEMA a WITH clause containing the PL/SQL code is added the SQL statement(s) created by GENERATE_SCHEMA. To ensure that the WITH block is only added when necessary, the query in GENERATE_SCHEMA is modified to count the number of BLOB and BFILE columns for each table as shown below select aat.owner ,aat.table_name ,SUM(CASE WHEN DATA_TYPE = &#39;BLOB&#39; THEN 1 ELSE 0 END) BLOB_COUNT ,SUM(CASE WHEN DATA_TYPE = &#39;BFILE&#39; THEN 1 ELSE 0 END) BFILE_COUNT ,cast(collect... A new method, GENERATE_WITH_CLAUSE is added to generate the WITH clause procedure GENERATE_WITH_CLAUSE(P_BFILE_COUNT NUMBER, P_BLOB_COUNT NUMBER, P_SQL_STATEMENT IN OUT CLOB) as begin if ((P_BFILE_COUNT = 0) and (P_BLOB_COUNT = 0)) then return; end if; DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(&#39;WITH&#39; || C_NEWLINE)); if (P_BFILE_COUNT &gt; 0) then DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(CODE_BFILE2CHAR)); end if; if (P_BLOB_COUNT &gt; 0) then DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(CODE_BLOB2HEXBINARY)); end if; end; This method is invoked in GENERATE schema prior to printing the ‘select’ into the LOB that contains the generated SQL statement. The next post will discuss how a similar technique can be used to support Oracle OBJECT types and the ANYDATA type.","@type":"BlogPosting","url":"http://localhost:4000/json/export/import/oracle/2018/06/17/BFILE-and-BLOB.html","headline":"Unsupported Data Types (Part 2)","dateModified":"2018-06-17T18:00:00-07:00","datePublished":"2018-06-17T18:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/json/export/import/oracle/2018/06/17/BFILE-and-BLOB.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="JSON Exchange" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">JSON Exchange</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Unsupported Data Types (Part 2)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-06-17T18:00:00-07:00" itemprop="datePublished">Jun 17, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="using-in-line-plsql-to-support-bfile-and-blob">Using In-line PL/SQL to support BFILE and BLOB</h2>

<p>The <a href="/json/export/import/oracle/2018/06/16/Unsupported-Scalar-Types.html">previous</a> post showed how to use SQL conversions to extend the set of data types that can be used with JSON_ARRAY. This post will build on that concept showing how in-line PL/SQL can be used in places where pure SQL is not sufficient.</p>

<p>JSON_ARRAY does not support the BFILE data type in any current release of the Oracle Database. A BFILE is basically a pointer to a file stored outside the database. The pointer consists of two components, a SQL Directory name and a path to the file, relative to the folder associated with the directory. There are 2 approaches to supporting the BFILE datatype.  The first is to inline the content of the file directly into the export, the second is to serialize the BFILE as a directory name and a relative path. In the current implementation of EXPORT_SCHEMA the second option is used.</p>

<p>It is not possible to extract this information directly a from BFILE column using SQL, so PL/SQL needs to be used.  The PL/SQL is extremely simple, given a BFILE column the method DBMS_LOB.FILEGETNAME will return the directory name and filename. However, since the FILEGETNAME method uses OUT parameters to return the required information it cannot be called directly from SQL, so a PL/SQL wrapper is required to allow FILEGETNAME to be invoked as part of the JSON_ARRAY operation.</p>

<p>The wrapper function is show below</p>

<pre><code class="language-SQL">function BFILE2CHAR(P_BFILE BFILE) return VARCHAR2
as
  V_SINGLE_QUOTE     CONSTANT CHAR(1) := CHR(39);
  V_DIRECTORY_ALIAS  VARCHAR2(128 CHAR);
  V_PATH2FILE        VARCHAR2(2000 CHAR);
begin
  DBMS_LOB.FILEGETNAME(P_BFILE,V_DIRECTORY_ALIAS,V_PATH2FILE);
  return 'BFILENAME(' || V_SINGLE_QUOTE || V_DIRECTORY_ALIAS || V_SINGLE_QUOTE || ',' 
                      || V_SINGLE_QUOTE || V_PATH2FILE || V_SINGLE_QUOTE || ')';
end;
</code></pre>

<p>It returns the directory and file names as the SQL function that was used when the BFILE was created.</p>

<p>A similar approach is taken in Oracle 12 when dealing with BLOB datatypes. Oracle 18 correctly outputs BLOB content as a HEXBINARY string. This behavior is mimicked in Oracle 12 by supplying  a PL/SQL wrapper that returns a CLOB containing the HEXBINARY representation of the BLOB.  The maximum size that can be handled using this approach is limited based on the return type specified for the JSON_ARRAY operation. Consequently, an error will be returned if the HEXBINARY representation of the input document is larger than the maximum size supported by the JSON_ARRAY operator. The size check assumes that the BLOB column is the only input to JSON_ARRAY, and it’s primary use is to avoid the overhead of serializing large documents in cases where the generated output cannot be processed further.</p>

<p>The following changes were made to the case statement in GENERATE_SCHEMA. For handling BLOBS in release 12</p>

<pre><code class="language-SQL">/*
** 18.1 compatible handling of BLOB
*/
when DATA_TYPE = 'BLOB'
  then 'BLOB2HEXBINARY("' || COLUMN_NAME || '")' 	
</code></pre>
<p>and for handling BFILES in all releases</p>

<pre><code class="language-SQL">/*
** Fix for BFILENAME
*/
when DATA_TYPE = 'BFILE'
  then 'BFILE2CHAR("' || COLUMN_NAME || '")'
</code></pre>
<p>In order to enable the use of these functions from EXPORT_SCHEMA a WITH clause containing the PL/SQL code is added the SQL statement(s) created by GENERATE_SCHEMA. To ensure that the WITH block is only added when necessary, the query in GENERATE_SCHEMA is modified to count the number of BLOB and BFILE columns for each table as shown below</p>

<pre><code class="language-SQL">select aat.owner
        ,aat.table_name
  	    ,SUM(CASE WHEN DATA_TYPE = 'BLOB'  THEN 1 ELSE 0 END) BLOB_COUNT
  	    ,SUM(CASE WHEN DATA_TYPE = 'BFILE' THEN 1 ELSE 0 END) BFILE_COUNT
	    ,cast(collect...
</code></pre>

<p>A new method, GENERATE_WITH_CLAUSE is added to generate the WITH clause</p>

<pre><code class="language-SQL">procedure GENERATE_WITH_CLAUSE(P_BFILE_COUNT NUMBER, P_BLOB_COUNT NUMBER, 
                               P_SQL_STATEMENT IN OUT CLOB)
as
begin
  if ((P_BFILE_COUNT = 0) and (P_BLOB_COUNT = 0)) then
    return;
  end if;
  DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB('WITH' || C_NEWLINE));
  if (P_BFILE_COUNT &gt; 0) then
    DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(CODE_BFILE2CHAR));
  end if;
  if (P_BLOB_COUNT &gt; 0) then
    DBMS_LOB.APPEND(P_SQL_STATEMENT,TO_CLOB(CODE_BLOB2HEXBINARY));
  end if;
end;

</code></pre>
<p>This method is invoked in GENERATE schema prior to printing the ‘select’ into the LOB that contains the generated SQL statement. The <a href="/json/export/import/oracle/2018/06/18/Objects-and-ANYDATA.html">next</a> post will discuss how a similar technique can be used to support Oracle OBJECT types and the ANYDATA type.</p>

  </div><a class="u-url" href="/json/export/import/oracle/2018/06/17/BFILE-and-BLOB.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">JSON Exchange</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">JSON Exchange</li><li><a class="u-email" href="mailto:mdd@appdev4db.com">mdd@appdev4db.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/markddrake"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">markddrake</span></a></li><li><a href="https://www.twitter.com/markddrake"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">markddrake</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>A simple utility for exporting and importing data using JSON</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
