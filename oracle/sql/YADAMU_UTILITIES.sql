create or replace package YADAMU_UTILITIES
authid CURRENT_USER
as
--
  JSON_OVERFLOW EXCEPTION; 
  PRAGMA EXCEPTION_INIT (JSON_OVERFLOW, -40478);
    
  C_NULL    CONSTANT NUMBER(1) := 0;
  C_BOOLEAN CONSTANT NUMBER(1) := 1;
  C_NUMERIC CONSTANT NUMBER(1) := 2;
  C_STRING  CONSTANT NUMBER(1) := 3;
  C_CLOB    CONSTANT NUMBER(1) := 4;
  C_JSON    CONSTANT NUMBER(1) := 5;

  C_NEWLINE         CONSTANT CHAR(1) := CHR(10);
  C_CARRIAGE_RETURN CONSTANT CHAR(1) := CHR(13);
  C_SINGLE_QUOTE    CONSTANT CHAR(1) := CHR(39);

$IF JSON_FEATURE_DETECTION.CLOB_SUPPORTED $THEN
$ELSE
  TYPE KVP_RECORD is RECORD (
    KEY               VARCHAR2(4000)
   ,DATA_TYPE         NUMBER
   ,NUMERIC_VALUE     NUMBER
   ,BOOLEAN_VALUE     BOOLEAN
    $IF JSON_FEATURE_DETECTION.EXTENDED_STRING_SUPPORTED $THEN
   ,STRING_VALUE      VARCHAR2(32767)
    $ELSE
   ,STRING_VALUE      VARCHAR2(4000)
    $END
   ,CLOB_VALUE        CLOB
  );
  
  TYPE KVP_TABLE is TABLE of KVP_RECORD;
  
  function KVNUL(KEY VARCHAR2) return KVP_RECORD;
  function KVB(KEY VARCHAR2,VALUE BOOLEAN) return KVP_RECORD;
  function KVN(KEY VARCHAR2,VALUE NUMBER) return KVP_RECORD;
  function KVS(KEY VARCHAR2,VALUE VARCHAR2) return KVP_RECORD;
  function KVC(KEY VARCHAR2,VALUE CLOB) return KVP_RECORD;  
  function KVJ(KEY VARCHAR2,VALUE CLOB) return KVP_RECORD;

  procedure JSON_OBJECT_CLOB(P_JSON_DOCUMENT IN OUT CLOB, P_KVP_LIST KVP_TABLE);
  function  JSON_OBJECT_CLOB(P_KVP_LIST KVP_TABLE) return CLOB;

  procedure JSON_ARRAYAGG_CLOB(P_JSON_DOCUMENT IN OUT CLOB, P_CURSOR SYS_REFCURSOR);
  function  JSON_ARRAYAGG_CLOB(P_CURSOR SYS_REFCURSOR) return CLOB;
--
$END
--  
END;
/
--
set TERMOUT on
--
show errors
--
@@SET_TERMOUT
--
create or replace package body YADAMU_UTILITIES
as
$IF JSON_FEATURE_DETECTION.CLOB_SUPPORTED $THEN
$ELSE
--
function KVNUL(KEY VARCHAR2) 
return KVP_RECORD
as
  KVP KVP_RECORD;
begin
  KVP.DATA_TYPE := C_NULL;
  KVP.KEY := KEY;
  return KVP;
end;
--
function KVB(KEY VARCHAR2, VALUE BOOLEAN) 
return KVP_RECORD
as
  KVP KVP_RECORD;
begin
  if (VALUE is NULL) then return KVNUL(KEY); end if;
  KVP.DATA_TYPE := C_BOOLEAN;
  KVP.KEY := KEY;
  KVP.BOOLEAN_VALUE := VALUE;
  return KVP;
end;
--
function KVN(KEY VARCHAR2, VALUE NUMBER) 
return KVP_RECORD
as
  KVP KVP_RECORD;
begin
  if (VALUE is NULL) then return KVNUL(KEY); end if;
  KVP.DATA_TYPE := C_NUMERIC;
  KVP.KEY := KEY;
  KVP.NUMERIC_VALUE := VALUE;
  return KVP;
end;
--
function KVJ(KEY VARCHAR2, VALUE CLOB) 
return KVP_RECORD
as
  KVP KVP_RECORD;
begin
  if (VALUE is NULL) then return KVNUL(KEY); end if;
  KVP.DATA_TYPE := C_JSON;
  KVP.KEY := KEY;
  KVP.CLOB_VALUE := VALUE;
  return KVP;
end;
--
function KVC(KEY VARCHAR2, VALUE CLOB) 
return KVP_RECORD
as
  V_VALUE_LENGTH PLS_INTEGER := DBMS_LOB.getLength(VALUE);
  KVP KVP_RECORD;

  $IF JSON_FEATURE_DETECTION.EXTENDED_STRING_SUPPORTED $THEN
  V_CHUNK          VARCHAR2(32767);
  V_CHUNK_ESCAPED  VARCHAR2(32767);
  $ELSE
  V_CHUNK           VARCHAR2(4000);
  V_CHUNK_ESCAPED   VARCHAR2(4000);
  $END

  V_CHUNK_START  NUMBER := 1;
  V_CHUNK_SIZE   NUMBER := JSON_FEATURE_DETECTION.C_MAX_STRING_SIZE-4;

begin
  if (VALUE is NULL) then return KVNUL(KEY); end if;
  KVP.DATA_TYPE := C_CLOB;
  KVP.KEY := KEY;
  -- Use JSON_ARRAY to create properly escapaed value of string content
  -- Write the Array Content (which is correctly escaped JSON) into the buffer.
  -- Strip the [" and "] from the escaped value.
  DBMS_LOB.CREATETEMPORARY(KVP.CLOB_VALUE,TRUE,DBMS_LOB.SESSION);
  while (V_CHUNK_START < V_VALUE_LENGTH) loop
    DBMS_LOB.READ(VALUE,V_CHUNK_SIZE,V_CHUNK_START,V_CHUNK);
    begin
      select JSON_ARRAY(V_CHUNK) 
        into V_CHUNK_ESCAPED
        from DUAL;
      DBMS_LOB.WRITEAPPEND(KVP.CLOB_VALUE,LENGTH(V_CHUNK_ESCAPED)-4,TRIM('"' FROM LTRIM(RTRIM(V_CHUNK_ESCAPED,']'),'[')));
    exception
      when JSON_OVERFLOW then
        select JSON_ARRAY(SUBSTR(V_CHUNK,1,FLOOR(JSON_FEATURE_DETECTION.C_MAX_STRING_SIZE/2))) 
          into V_CHUNK_ESCAPED
          from DUAL;
        DBMS_LOB.WRITEAPPEND(KVP.CLOB_VALUE,LENGTH(V_CHUNK_ESCAPED)-4,TRIM('"' FROM LTRIM(RTRIM(V_CHUNK_ESCAPED,']'),'[')));
        if (LENGTH(V_CHUNK) > FLOOR(JSON_FEATURE_DETECTION.C_MAX_STRING_SIZE/2)) then 
          select JSON_ARRAY(SUBSTR(V_CHUNK,CEIL(JSON_FEATURE_DETECTION.C_MAX_STRING_SIZE/2))) 
               into V_CHUNK_ESCAPED
              from DUAL;
          DBMS_LOB.WRITEAPPEND(KVP.CLOB_VALUE,LENGTH(V_CHUNK_ESCAPED)-4,TRIM('"' FROM LTRIM(RTRIM(V_CHUNK_ESCAPED,']'),'[')));
        end if;
      when OTHERS then
        RAISE;
    end;
    V_CHUNK_START := V_CHUNK_START + V_CHUNK_SIZE;
    V_CHUNK_SIZE := JSON_FEATURE_DETECTION.C_MAX_STRING_SIZE-4;
  end loop;  
  return KVP;
end;
--
function KVS(KEY VARCHAR2, VALUE VARCHAR2) 
return KVP_RECORD
as
  KVP KVP_RECORD;
begin
  if (VALUE is NULL) then return KVNUL(KEY); end if;
  KVP.DATA_TYPE := C_STRING;
  KVP.KEY := KEY;
  -- Use JSON_ARRAY to create properly escapaed value of string content
  -- Write the Array Content (which is correctly escaped JSON) into the buffer.
  -- Strip the [" and "] from the escaped value.
  select TRIM('"' FROM LTRIM(RTRIM(JSON_ARRAY(VALUE),']'),'['))
    into KVP.STRING_VALUE
    from DUAL;
  return KVP;
exception
  when JSON_OVERFLOW then
    return KVC(KEY, VALUE);
  when OTHERS then
    RAISE;
end;
--
procedure JSON_OBJECT_CLOB(P_JSON_DOCUMENT IN OUT CLOB, P_KVP_LIST KVP_TABLE)
as
begin
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'{');  
  for i in P_KVP_LIST.FIRST .. P_KVP_LIST.LAST loop
    if (i > 1) then DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,','); end if;  
    DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'"');  
    DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,length(P_KVP_LIST(i).KEY),P_KVP_LIST(i).KEY);  
    DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'"');  
    DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,':');  
    case 
      when P_KVP_LIST(i).DATA_TYPE = C_NULL then
        DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,length('null'),'null');  
      when P_KVP_LIST(i).DATA_TYPE = C_BOOLEAN and P_KVP_LIST(i).BOOLEAN_VALUE then
        DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,length('true'),'true');  
      when P_KVP_LIST(i).DATA_TYPE = C_BOOLEAN and not P_KVP_LIST(i).BOOLEAN_VALUE then
        DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,length('false'),'false');  
      when P_KVP_LIST(i).DATA_TYPE = C_NUMERIC then
        DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,length(TO_CHAR(P_KVP_LIST(i).NUMERIC_VALUE)),TO_CHAR(P_KVP_LIST(i).NUMERIC_VALUE));
      when P_KVP_LIST(i).DATA_TYPE = C_JSON then
        DBMS_LOB.APPEND(P_JSON_DOCUMENT,P_KVP_LIST(i).CLOB_VALUE);
      when P_KVP_LIST(i).DATA_TYPE = C_STRING then
        DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'"');  
        DBMS_LOB.APPEND(P_JSON_DOCUMENT,P_KVP_LIST(i).STRING_VALUE);
        DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'"');  
      when P_KVP_LIST(i).DATA_TYPE = C_CLOB then
        DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'"');  
        DBMS_LOB.APPEND(P_JSON_DOCUMENT,P_KVP_LIST(i).CLOB_VALUE);
        DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'"');  
    end case;
  end loop;
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'}');  
end;
--
function  JSON_OBJECT_CLOB(P_KVP_LIST KVP_TABLE)
return CLOB
as
  V_RESULT CLOB;
begin
  DBMS_LOB.CREATETEMPORARY(V_RESULT,TRUE,DBMS_LOB.SESSION);
  JSON_OBJECT_CLOB(V_RESULT,P_KVP_LIST);
  return V_RESULT;
end;
--
procedure JSON_ARRAYAGG_CLOB(P_JSON_DOCUMENT IN OUT CLOB, P_CURSOR SYS_REFCURSOR)
as
  JSON_ARRAY_OVERFLOW EXCEPTION; PRAGMA EXCEPTION_INIT (JSON_ARRAY_OVERFLOW, -40478);
  V_SEPERATOR         VARCHAR2(1) := ',';
  $IF JSON_FEATURE_DETECTION.EXTENDED_STRING_SUPPORTED $THEN
  V_ARRAY_MEMBER VARCHAR2(32767);
  $ELSE
  V_ARRAY_MEMBER VARCHAR2(4000);
  $END
  V_START_ARRAY_DATA  PLS_INTEGER;
  V_JSON_ARRAY_ERROR  CLOB;
  V_FIRST_MEMBER      BOOLEAN := true;
begin
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,'[');  
  V_START_ARRAY_DATA := DBMS_LOB.GETLENGTH(P_JSON_DOCUMENT);
  loop
    begin
      fetch P_CURSOR into V_ARRAY_MEMBER;
      exit when P_CURSOR%notfound;
      if (NOT V_FIRST_MEMBER) then DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,length(V_SEPERATOR),V_SEPERATOR); end if;
      V_FIRST_MEMBER := false;
      DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,length(V_ARRAY_MEMBER),V_ARRAY_MEMBER);
    exception
      when others then
        select JSON_OBJECT(
	  	         'error' value DBMS_UTILITY.FORMAT_ERROR_STACK
--
                 $IF JSON_FEATURE_DETECTION.EXTENDED_STRING_SUPPORTED $THEN
                 returning VARCHAR2(32767)
                 $ELSE
                 returning VARCHAR2(4000)
                 $END
--
               )
          into V_JSON_ARRAY_ERROR
	      from DUAL;
        DBMS_LOB.TRIM(P_JSON_DOCUMENT,V_START_ARRAY_DATA);
        DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,LENGTH(V_JSON_ARRAY_ERROR),V_JSON_ARRAY_ERROR);
        exit;
    end;
  end loop;
  DBMS_LOB.WRITEAPPEND(P_JSON_DOCUMENT,1,']');  
end;
--
function JSON_ARRAYAGG_CLOB(P_CURSOR SYS_REFCURSOR) 
return CLOB
as
  V_RESULT CLOB;
begin
  DBMS_LOB.CREATETEMPORARY(V_RESULT,TRUE,DBMS_LOB.SESSION);
  JSON_ARRAYAGG_CLOB(V_RESULT,P_CURSOR);
  return V_RESULT;
end;
--
$END
--
end;
/
--
set TERMOUT on
--
show errors
--
@@SET_TERMOUT
--